{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{221:function(t,a,e){\"use strict\";e.r(a);var i=e(0),_=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"div\",{staticClass:\"content\"},[e(\"h2\",{attrs:{id:\"_304-的缓存原理\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_304-的缓存原理\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 304 的缓存原理\")]),t._v(\" \"),e(\"blockquote\",[e(\"p\",[t._v(\"添加 Etag 标签 last-modified） 304 网页上次请求没有更新，节省带宽和开销\")])]),t._v(\" \"),e(\"p\",[t._v(\"1.服务器首先产生\"),e(\"strong\",[t._v(\"Etag\")]),t._v(\"(服务器可在稍后使用它来判断页面是否被修改)。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）\")]),t._v(\" \"),e(\"p\",[t._v(\"2.304 是 HTTP 的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件\")]),t._v(\" \"),e(\"p\",[t._v(\"3.流程：客户端请求一个页面 A。服务器返回页面 A，并在 A 上加一个 Tage 客服端渲染该页面，并把 Tage 也存储在缓存中。客户端再次请求页面 A\\n并将上次请求的资源和 ETage 一起传递给服务器。服务器检查 Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回 304\")]),t._v(\" \"),e(\"p\",[t._v(\"last-modified: 客服端请求资源，同时有一个 last-modified 的属性标记此文件在服务器最后修改的时间\\n客服端第二次请求此 url 时，根据 http 协议。浏览器会向服务器发送一个 If-Modified-Since 报头，\\n询问该事件之后文件是否被修改，没修改返回 304\")]),t._v(\" \"),e(\"p\",[t._v(\"有了 Last-Modified，为什么还要用 ETag？\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified 就会不正确（Last—Modified 不能识别秒单位的修改）\")]),t._v(\" \"),e(\"li\",[t._v(\"某些服务器不能精确的得到文件的最后修改时间\")]),t._v(\" \"),e(\"li\",[t._v(\"一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新 Get\")])]),t._v(\" \"),e(\"p\",[t._v(\"ETag，为什么还要用 Last-Modified？\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"两者互补，ETag 的判断的缺陷，比如一些图片等静态文件的修改\\n2.如果每次扫描内容都生成 ETag 比较，显然要比直接比较修改时间慢的多。\")])]),t._v(\" \"),e(\"p\",[t._v(\"ETag 是被请求变量的实体值（文件的索引节，大小和最后修改的时间的 Hash 值）\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"ETag 的值服务器端对文件的索引节，大小和最后的修改的事件进行 Hash 后得到的。\")])])])}],!1,null,null,null);a.default=_.exports}}]);","extractedComments":[]}