{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{191:function(t,e,_){\"use strict\";_.r(e);var v=_(0),n=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,_=t._self._c||e;return _(\"div\",{staticClass:\"content\"},[_(\"h1\",{attrs:{id:\"nexttick\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nexttick\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" nextTick\")]),t._v(\" \"),_(\"blockquote\",[_(\"p\",[t._v(\"在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\")])]),t._v(\" \"),_(\"p\",[t._v(\"Vue 在更新 DOM 时是\"),_(\"strong\",[t._v(\"异步\")]),t._v(\"执行的\")]),t._v(\" \"),_(\"p\",[t._v(\"只要侦听到数据变化，Vue 将开启一个\"),_(\"strong\",[t._v(\"队列\")]),t._v(\"，并\"),_(\"strong\",[t._v(\"缓冲\")]),t._v(\"在\"),_(\"strong\",[t._v(\"同一事件循环\")]),t._v(\"中发生的所有数据变更\")]),t._v(\" \"),_(\"p\",[t._v(\"如果\"),_(\"strong\",[t._v(\"同一个 watcher\")]),t._v(\" 被多次触发，只会被 \"),_(\"strong\",[t._v(\"推入到队列中一次\")]),t._v(\"。这种在缓冲时去除重复数据对于避免不必要的\"),_(\"strong\",[t._v(\"计算\")]),t._v(\"和 \"),_(\"strong\",[t._v(\"DOM 操作\")]),t._v(\"是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作\")]),t._v(\" \"),_(\"p\",[t._v(\"Vue 在内部对异步队列尝试使用原生的 \"),_(\"code\",[t._v(\"Promise.then\")]),t._v(\"、\"),_(\"code\",[t._v(\"MutationObserver\")]),t._v(\"(监视对DOM树所做更改的能力) 和 \"),_(\"code\",[t._v(\"setImmediate\")]),t._v(\"，如果执行环境不支持，则会采用 \"),_(\"code\",[t._v(\"setTimeout(fn, 0)\")]),t._v(\" 代替。\")])])}],!1,null,null,null);e.default=n.exports}}]);","extractedComments":[]}