{"remainingRequest":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js??ref--1-0!/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/takki/blog/docs/Vue/nextTick.md?vue&type=template&id=52bd61e4&","dependencies":[{"path":"/Users/takki/blog/docs/Vue/nextTick.md","mtime":1570762823351},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"nexttick\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#nexttick\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" nextTick\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [\n        _c(\"p\", [\n          _vm._v(\n            \"在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"Vue 在更新 DOM 时是\"),\n        _c(\"strong\", [_vm._v(\"异步\")]),\n        _vm._v(\"执行的\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"只要侦听到数据变化，Vue 将开启一个\"),\n        _c(\"strong\", [_vm._v(\"队列\")]),\n        _vm._v(\"，并\"),\n        _c(\"strong\", [_vm._v(\"缓冲\")]),\n        _vm._v(\"在\"),\n        _c(\"strong\", [_vm._v(\"同一事件循环\")]),\n        _vm._v(\"中发生的所有数据变更\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"如果\"),\n        _c(\"strong\", [_vm._v(\"同一个 watcher\")]),\n        _vm._v(\" 被多次触发，只会被 \"),\n        _c(\"strong\", [_vm._v(\"推入到队列中一次\")]),\n        _vm._v(\"。这种在缓冲时去除重复数据对于避免不必要的\"),\n        _c(\"strong\", [_vm._v(\"计算\")]),\n        _vm._v(\"和 \"),\n        _c(\"strong\", [_vm._v(\"DOM 操作\")]),\n        _vm._v(\n          \"是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"Vue 在内部对异步队列尝试使用原生的 \"),\n        _c(\"code\", [_vm._v(\"Promise.then\")]),\n        _vm._v(\"、\"),\n        _c(\"code\", [_vm._v(\"MutationObserver\")]),\n        _vm._v(\"(监视对DOM树所做更改的能力) 和 \"),\n        _c(\"code\", [_vm._v(\"setImmediate\")]),\n        _vm._v(\"，如果执行环境不支持，则会采用 \"),\n        _c(\"code\", [_vm._v(\"setTimeout(fn, 0)\")]),\n        _vm._v(\" 代替。\")\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}