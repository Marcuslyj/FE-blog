{"remainingRequest":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/takki/blog/docs/browser/浏览器渲染过程.md?vue&type=template&id=20c4d036&","dependencies":[{"path":"/Users/takki/blog/docs/browser/浏览器渲染过程.md","mtime":1549960244620},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"浏览器渲染过程\"><a class=\"header-anchor\" href=\"#浏览器渲染过程\" aria-hidden=\"true\">#</a> 浏览器渲染过程</h1>\n<p>浏览器的渲染机制一般分为以下几个步骤</p>\n<ol>\n<li>处理 HTML 并构建 DOM 树。</li>\n<li>处理 CSS 构建 CSSOM 树。</li>\n<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>\n<li>根据渲染树来布局，计算每个节点的位置。</li>\n<li>调用 GPU 绘制，合成图层，显示在屏幕上。</li>\n</ol>\n<p><img src=\"/img/render.png\" alt=\"'render'\"></p>\n<p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</p>\n<p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</p>\n<h2 id=\"load-和-domcontentloaded-区别\"><a class=\"header-anchor\" href=\"#load-和-domcontentloaded-区别\" aria-hidden=\"true\">#</a> Load 和 DOMContentLoaded 区别</h2>\n<p>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。</p>\n<p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</p>\n<h2 id=\"重绘（repaint）和回流（reflow）\"><a class=\"header-anchor\" href=\"#重绘（repaint）和回流（reflow）\" aria-hidden=\"true\">#</a> 重绘（Repaint）和回流（Reflow）</h2>\n<p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p>\n<ul>\n<li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li>\n<li>回流是布局或者几何属性需要改变就称为回流。</li>\n<li>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</li>\n</ul>\n<p>会导致回流的操作：</p>\n<ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生改变</li>\n<li>元素尺寸或位置发生改变</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或者删除可见的 DOM 元素</li>\n<li>激活 CSS 伪类（例如：:hover）</li>\n<li>查询某些属性或调用某些方法</li>\n</ul>\n<h2 id=\"减少重绘和回流\"><a class=\"header-anchor\" href=\"#减少重绘和回流\" aria-hidden=\"true\">#</a> 减少重绘和回流</h2>\n<h3 id=\"css\"><a class=\"header-anchor\" href=\"#css\" aria-hidden=\"true\">#</a> CSS</h3>\n<ul>\n<li>避免使用 table 布局。</li>\n<li>尽可能在 DOM 树的最末端改变 class。</li>\n<li>避免设置多层内联样式。</li>\n<li>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。</li>\n<li>避免使用 CSS 表达式（例如：calc()）。</li>\n</ul>\n<h3 id=\"javascript\"><a class=\"header-anchor\" href=\"#javascript\" aria-hidden=\"true\">#</a> JavaScript</h3>\n<ul>\n<li>避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。</li>\n<li>避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。</li>\n<li>也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li>\n<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>\n<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>\n</ul>\n</div>\n",null]}