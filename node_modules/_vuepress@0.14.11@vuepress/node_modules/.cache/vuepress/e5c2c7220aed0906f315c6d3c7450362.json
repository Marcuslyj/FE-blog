{"remainingRequest":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js??ref--1-0!/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/takki/blog/docs/Vue/解释器.md?vue&type=template&id=f7f9bc9c&","dependencies":[{"path":"/Users/takki/blog/docs/Vue/解释器.md","mtime":1574674828959},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"解释器\\\"><a href=\\\"#解释器\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 解释器</h1> <p>解析器的作用是通过模板得到 AST（抽象语法树）。</p> <p>生成 AST 的过程需要借助 HTML 解析器，当 HTML 解析器触发不同的<strong>钩子函数</strong>时，我们可以构建出不同的节点。</p> <div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token function\\\">parseHTML</span><span class=\\\"token punctuation\\\">(</span>template<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">start</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token parameter\\\">tag<span class=\\\"token punctuation\\\">,</span> attrs<span class=\\\"token punctuation\\\">,</span> unary</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> \\n    <span class=\\\"token comment\\\">// 每当解析到标签的开始位置时，触发该函数</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token function\\\">end</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// 每当解析到标签的结束位置时，触发该函数</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token function\\\">chars</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token parameter\\\">text</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// 每当解析到文本时，触发该函数</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token function\\\">comment</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token parameter\\\">text</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// 每当解析到注释时，触发该函数</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><p><img src=\\\"https://camo.githubusercontent.com/b5726c5705d0197cb3573dcb64bd95f8c30f2e09/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031643135393137633934643561333462662e6a7067\\\" alt></p> <p>随后，我们可以通过<strong>栈</strong>来得到当前正在构建的节点的父节点，然后将构建出的节点添加到父节点的下面。</p> <p>最终，当 HTML 解析器运行完毕后，我们就可以得到一个完整的带 DOM 层级关系的 AST。</p> <p>HTML 解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行。</p> <p>文本分两种类型，不带变量的纯文本和带变量的文本，后者需要使用文本解析器进行二次加工。</p>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}