{"remainingRequest":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/takki/blog/docs/Vue/解释器.md?vue&type=template&id=f7f9bc9c&","dependencies":[{"path":"/Users/takki/blog/docs/Vue/解释器.md","mtime":1574674828959},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"解释器\"><a class=\"header-anchor\" href=\"#解释器\" aria-hidden=\"true\">#</a> 解释器</h1>\n<p>解析器的作用是通过模板得到 AST（抽象语法树）。</p>\n<p>生成 AST 的过程需要借助 HTML 解析器，当 HTML 解析器触发不同的<strong>钩子函数</strong>时，我们可以构建出不同的节点。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token function\">parseHTML</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tag<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">,</span> unary</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token comment\">// 每当解析到标签的开始位置时，触发该函数</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 每当解析到标签的结束位置时，触发该函数</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">chars</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 每当解析到文本时，触发该函数</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">comment</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 每当解析到注释时，触发该函数</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><img src=\"https://camo.githubusercontent.com/b5726c5705d0197cb3573dcb64bd95f8c30f2e09/68747470733a2f2f70302e73736c2e7168696d672e636f6d2f743031643135393137633934643561333462662e6a7067\" alt=\"\"></p>\n<p>随后，我们可以通过<strong>栈</strong>来得到当前正在构建的节点的父节点，然后将构建出的节点添加到父节点的下面。</p>\n<p>最终，当 HTML 解析器运行完毕后，我们就可以得到一个完整的带 DOM 层级关系的 AST。</p>\n<p>HTML 解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行。</p>\n<p>文本分两种类型，不带变量的纯文本和带变量的文本，后者需要使用文本解析器进行二次加工。</p>\n</div>\n",null]}