{"remainingRequest":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js??ref--1-0!/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/takki/blog/docs/http/304.md?vue&type=template&id=3187eb0b&","dependencies":[{"path":"/Users/takki/blog/docs/http/304.md","mtime":1574412879155},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h2 id=\\\"_304-的缓存原理\\\"><a href=\\\"#_304-的缓存原理\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 304 的缓存原理</h2> <blockquote><p>添加 Etag 标签 last-modified） 304 网页上次请求没有更新，节省带宽和开销</p></blockquote> <p>1.服务器首先产生<strong>Etag</strong>(服务器可在稍后使用它来判断页面是否被修改)。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）</p> <p>2.304 是 HTTP 的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件</p> <p>3.流程：客户端请求一个页面 A。服务器返回页面 A，并在 A 上加一个 Tage 客服端渲染该页面，并把 Tage 也存储在缓存中。客户端再次请求页面 A\\n并将上次请求的资源和 ETage 一起传递给服务器。服务器检查 Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回 304</p> <p>last-modified: 客服端请求资源，同时有一个 last-modified 的属性标记此文件在服务器最后修改的时间\\n客服端第二次请求此 url 时，根据 http 协议。浏览器会向服务器发送一个 If-Modified-Since 报头，\\n询问该事件之后文件是否被修改，没修改返回 304</p> <p>有了 Last-Modified，为什么还要用 ETag？</p> <ol><li>因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified 就会不正确（Last—Modified 不能识别秒单位的修改）</li> <li>某些服务器不能精确的得到文件的最后修改时间</li> <li>一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新 Get</li></ol> <p>ETag，为什么还要用 Last-Modified？</p> <ol><li>两者互补，ETag 的判断的缺陷，比如一些图片等静态文件的修改\\n2.如果每次扫描内容都生成 ETag 比较，显然要比直接比较修改时间慢的多。</li></ol> <p>ETag 是被请求变量的实体值（文件的索引节，大小和最后修改的时间的 Hash 值）</p> <ol><li>ETag 的值服务器端对文件的索引节，大小和最后的修改的事件进行 Hash 后得到的。</li></ol>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}