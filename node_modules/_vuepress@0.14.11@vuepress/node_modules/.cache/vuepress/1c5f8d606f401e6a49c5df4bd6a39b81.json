{"remainingRequest":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/takki/blog/docs/Vue/nextTick.md?vue&type=template&id=502c09ed&","dependencies":[{"path":"/Users/takki/blog/docs/Vue/nextTick.md","mtime":1570762823351},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/takki/blog/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"nexttick\"><a class=\"header-anchor\" href=\"#nexttick\" aria-hidden=\"true\">#</a> nextTick</h1>\n<blockquote>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n</blockquote>\n<p>Vue 在更新 DOM 时是<strong>异步</strong>执行的</p>\n<p>只要侦听到数据变化，Vue 将开启一个<strong>队列</strong>，并<strong>缓冲</strong>在<strong>同一事件循环</strong>中发生的所有数据变更</p>\n<p>如果<strong>同一个 watcher</strong> 被多次触发，只会被 <strong>推入到队列中一次</strong>。这种在缓冲时去除重复数据对于避免不必要的<strong>计算</strong>和 <strong>DOM 操作</strong>是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作</p>\n<p>Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code>(监视对DOM树所做更改的能力) 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n</div>\n",null]}